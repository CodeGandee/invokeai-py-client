#!/usr/bin/env python3
"""
InvokeAI Job Queue Direct Database Hack

This script bypasses the InvokeAI API and directly queries the SQLite database
to get the latest finished job efficiently. This is a "hack" approach that
provides maximum performance but requires direct database access.

WARNING: This approach:
- Bypasses the official API
- Requires knowledge of the database schema
- May break if InvokeAI changes the database structure
- Should be used with caution in production environments

Database Schema (from migration_1.py):
- Table: session_queue
- Key fields: item_id (PK), status, created_at, completed_at, session (JSON)
- Sorting: item_id is autoincrement, so MAX(item_id) = latest job
"""

import sqlite3
import json
import os
from datetime import datetime
from typing import Optional, Dict, Any
import requests

# Database configuration
DATABASE_PATH = r"F:\invoke-ai-app\databases\invokeai.db"
INVOKEAI_URL = "http://localhost:9090"

def check_database_exists() -> bool:
    """Check if the InvokeAI database exists at the specified path."""
    if not os.path.exists(DATABASE_PATH):
        print(f"‚ùå Database not found at: {DATABASE_PATH}")
        return False
    
    print(f"‚úÖ Database found at: {DATABASE_PATH}")
    return True

def get_latest_completed_job_direct() -> Optional[Dict[str, Any]]:
    """Get the latest completed job by directly querying the SQLite database."""
    conn = None
    try:
        # Connect to the database
        conn = sqlite3.connect(DATABASE_PATH)
        conn.row_factory = sqlite3.Row  # This allows accessing columns by name
        cursor = conn.cursor()
        
        # Query for the latest completed job using MAX(item_id) for efficiency
        # This is much faster than ORDER BY + LIMIT since item_id is the primary key
        query = """
        SELECT *
        FROM session_queue
        WHERE status = 'completed'
        AND item_id = (
            SELECT MAX(item_id)
            FROM session_queue
            WHERE status = 'completed'
        )
        """
        
        print("üîç Executing direct database query for latest completed job...")
        cursor.execute(query)
        result = cursor.fetchone()
        
        if result is None:
            print("No completed jobs found in database")
            return None
        
        # Convert sqlite3.Row to dict
        job_data = dict(result)
        
        # Parse the session JSON to extract additional metadata
        if job_data.get('session'):
            try:
                session_data = json.loads(job_data['session'])
                job_data['parsed_session'] = session_data
            except json.JSONDecodeError as e:
                print(f"Warning: Could not parse session JSON: {e}")
        
        print(f"‚úÖ Found latest completed job: ID {job_data['item_id']}")
        return job_data
        
    except sqlite3.Error as e:
        print(f"‚ùå Database error: {e}")
        return None
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        return None
    finally:
        if conn is not None:
            conn.close()

def get_queue_stats_direct() -> Dict[str, int]:
    """Get queue statistics directly from the database."""
    conn = None
    try:
        conn = sqlite3.connect(DATABASE_PATH)
        cursor = conn.cursor()
        
        # Get counts by status
        query = """
        SELECT status, COUNT(*) as count
        FROM session_queue
        GROUP BY status
        """
        
        cursor.execute(query)
        results = cursor.fetchall()
        
        stats = {}
        total = 0
        for row in results:
            status, count = row
            stats[status] = count
            total += count
        
        stats['total'] = total
        return stats
        
    except sqlite3.Error as e:
        print(f"Database error getting stats: {e}")
        return {}
    finally:
        if conn is not None:
            conn.close()

def extract_generated_image_from_session(session_data: Dict[str, Any]) -> Optional[str]:
    """Extract the generated image name from the parsed session data."""
    try:
        # Look for results in the session
        results = session_data.get('results', {})
        
        # Find image output in the results
        for node_id, result in results.items():
            if result.get('type') == 'image_output':
                image_data = result.get('image', {})
                return image_data.get('image_name')
        
        return None
    except Exception as e:
        print(f"Error extracting image from session: {e}")
        return None

def download_job_image(image_name: str, download_dir: str = "./tmp/downloads/") -> bool:
    """Download the image generated by a job."""
    if not image_name:
        print("No image name provided")
        return False
    
    try:
        from pathlib import Path
        
        # Create download directory
        Path(download_dir).mkdir(parents=True, exist_ok=True)
        
        # Download the image using InvokeAI API
        image_url = f"{INVOKEAI_URL}/api/v1/images/i/{image_name}/full"
        response = requests.get(image_url)
        response.raise_for_status()
        
        # Save the image
        file_path = os.path.join(download_dir, image_name)
        with open(file_path, 'wb') as f:
            f.write(response.content)
        
        file_size = os.path.getsize(file_path)
        print(f"üì• Downloaded: {file_path} ({file_size:,} bytes)")
        return True
        
    except Exception as e:
        print(f"‚ùå Error downloading image: {e}")
        return False

def display_job_summary(job_data: Dict[str, Any]):
    """Display a summary of the job data."""
    print(f"\n{'='*60}")
    print(f"üéØ LATEST COMPLETED JOB (Direct Database Query)")
    print(f"{'='*60}")
    
    # Basic job info
    print(f"Job ID: {job_data.get('item_id')}")
    print(f"Queue ID: {job_data.get('queue_id')}")
    print(f"Session ID: {job_data.get('session_id')}")
    print(f"Batch ID: {job_data.get('batch_id')}")
    print(f"Status: {job_data.get('status')}")
    print(f"Priority: {job_data.get('priority')}")
    
    # Timestamps
    created_at = job_data.get('created_at')
    completed_at = job_data.get('completed_at')
    
    if created_at:
        print(f"Created: {created_at}")
    
    if completed_at:
        print(f"Completed: {completed_at}")
        
        # Calculate duration if both timestamps are available
        if created_at:
            try:
                # Parse SQLite datetime format
                created_time = datetime.strptime(created_at, '%Y-%m-%d %H:%M:%S.%f')
                completed_time = datetime.strptime(completed_at, '%Y-%m-%d %H:%M:%S.%f')
                duration = completed_time - created_time
                print(f"‚è±Ô∏è  Duration: {duration.total_seconds():.2f} seconds")
            except ValueError as e:
                print(f"Could not calculate duration: {e}")
    
    # Extract image from session
    session_data = job_data.get('parsed_session')
    if session_data:
        image_name = extract_generated_image_from_session(session_data)
        if image_name:
            print(f"üñºÔ∏è  Generated Image: {image_name}")
            return image_name
    
    return None

def performance_comparison():
    """Compare performance between direct database query and API approach."""
    import time
    
    print(f"\n{'='*60}")
    print("‚ö° PERFORMANCE COMPARISON")
    print(f"{'='*60}")
    
    # Test direct database approach
    start_time = time.time()
    latest_job_db = get_latest_completed_job_direct()
    db_time = time.time() - start_time
    
    if latest_job_db:
        print(f"‚úÖ Direct DB Query: {db_time:.4f} seconds")
        print(f"   Found job ID: {latest_job_db['item_id']}")
    else:
        print("‚ùå Direct DB Query failed")
        return
    
    # Test API approach for comparison
    start_time = time.time()
    try:
        response = requests.get(f"{INVOKEAI_URL}/api/v1/queue/default/list_all")
        all_jobs = response.json()
        completed_jobs = [job for job in all_jobs if job.get('status') == 'completed']
        latest_job_api = completed_jobs[-1] if completed_jobs else None
        api_time = time.time() - start_time
        
        if latest_job_api:
            print(f"üì° API Approach: {api_time:.4f} seconds")
            print(f"   Found job ID: {latest_job_api['item_id']}")
            
            # Compare results
            if latest_job_db['item_id'] == latest_job_api['item_id']:
                print(f"‚úÖ Both methods found the same job")
                print(f"‚ö° Direct DB is {api_time/db_time:.1f}x faster!")
            else:
                print(f"‚ö†Ô∏è  Different results: DB={latest_job_db['item_id']}, API={latest_job_api['item_id']}")
        else:
            print("‚ùå API approach failed")
            
    except Exception as e:
        print(f"‚ùå API approach failed: {e}")

def demo_direct_database_hack():
    """Main demo function showing the direct database approach."""
    print("üéØ InvokeAI Job Queue Direct Database Hack")
    print("=" * 50)
    
    # Check if database exists
    if not check_database_exists():
        return
    
    # Get queue statistics
    print("\nüìä Queue Statistics (Direct DB):")
    stats = get_queue_stats_direct()
    for status, count in stats.items():
        print(f"   {status}: {count}")
    
    # Get latest completed job
    latest_job = get_latest_completed_job_direct()
    
    if not latest_job:
        print("No completed jobs found")
        return
    
    # Display job summary
    image_name = display_job_summary(latest_job)
    
    # Download the generated image
    if image_name:
        print(f"\nüì• Downloading generated image...")
        success = download_job_image(image_name)
        
        if success:
            print(f"\nüéâ Successfully retrieved and downloaded the latest finished job!")
        else:
            print(f"\n‚ö†Ô∏è  Job retrieved but image download failed")
    
    # Performance comparison
    performance_comparison()

if __name__ == "__main__":
    try:
        demo_direct_database_hack()
        
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è  Demo interrupted by user")
    except Exception as e:
        print(f"\n‚ùå Unexpected error: {e}")
        print("Make sure InvokeAI is running and the database path is correct")
